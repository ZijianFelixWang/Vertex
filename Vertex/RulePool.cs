using System;
using System.Collections.Generic;
//using System.Collections;

namespace Vertex
{
    class RulePool
    {
        // here implements the rule pool.
        // a rule is actually a bool[]

        // Definition of a rule:
        /*
         * Each cell in the matrix (excepted some configured VCIO cells) is
         * executed according to the general rule generated by RulePool.Next
         */

        public readonly ushort RuleLength = 0;

        public static int GetTimeStamp()
        {
            TimeSpan ts = DateTime.UtcNow - new DateTime(1970, 1, 1, 0, 0, 0, 0);
            return (int)Convert.ToInt64(ts.TotalMilliseconds);
        }

        public RulePool(ushort RuleLength)
        {
            // Actually is 512 but magical numbers should be avoided!
            this.RuleLength = RuleLength;

            // During initialization of env.RulePool, the very-first random rule
            // (Generation 0) will be created using the procedures below.
            bool[] gen0 = new bool[RuleLength];
            Console.Write("G0= ");
            for (int i = 0; i < RuleLength; i++)
            {
                gen0[i] = Convert.ToBoolean(new Random(GetTimeStamp()).Next(0, 2));
                Console.Write(gen0[i] ? "1" : "0");
            }
            Console.WriteLine();
            ruleHistory.Add(gen0);

            System.Threading.Thread.Sleep(2500);

            // (Generation 1) will be created using the procedures below.
            bool[] gen1 = new bool[RuleLength];
            Console.Write("G1= ");
            for (int i = 0; i < RuleLength; i++)
            {
                gen1[i] = Convert.ToBoolean(new Random(GetTimeStamp()).Next(0, 2));
                Console.Write(gen1[i] ? "1" : "0");
            }
            ruleHistory.Add(gen1);
            Console.WriteLine();
        }

        public bool[] GetLatest() => ruleHistory[^1];

        public List<bool[]> ruleHistory = new List<bool[]>();

        // rulepool doesn't care about how to execute rules. it only knows that
        // a rule is constructed using 512 bits (see Evaluator.cs)

        // Random maker
        private Random rand = new Random(new Random(GetTimeStamp()).Next());

        public bool[] Next(List<short> RankingHistory) => GetLatest();
        public bool[] Next() => GetLatest();

        public bool[] Produce(List<short> RankingHistory)
        {
            if (RankingHistory is null)
            {
                throw new ArgumentNullException(nameof(RankingHistory));
            }

            // Function summary
            /*
             * Input:   None
             * Output:  Next rule
             * Features:
             *  This function returns next rule to perform according to the 
             *  rule ranking information. The ranking information is the
             *  comment ushort number to the performance of the current rule 
             *  which is just evaluated. The executor
             */

            // Just tried:  RankingHistory[RankingHistory.Count-1]
            //              OR: RankingHistory[^1]
            // Just tried:  ruleHistory[ruleHistory.Count-1]
            //              OR: ruleHistory[^1]

            // Detailed things to do:
            /*
             * If new ranking is greater than last one, mutate new ranking's rule
             * If new ranking is the same as last one, crossover rules then mutate
             * If new ranking is less than last one, mutate last ranking's rule
             * After this process record the new rule to history and then return it.
             */

            if (RankingHistory[^1] > RankingHistory[^2])
            {
                // Situation 1
                Console.WriteLine("S_1");

                int ToMutate = rand.Next(0, RuleLength);
                bool MutateToWhat = rand.Next(0, 2) == 1;
                ruleHistory.Add(ruleHistory[^1]);
                ruleHistory[^1][ToMutate] = MutateToWhat;
            }

            if (RankingHistory[^1] == RankingHistory[^2])
            {
                // Situation 2
                Console.WriteLine("S_2");

                // Single-Point Crossover (SPCV) Algorithm:
                // For Example: (NOT REALLY 512 LENGTH ARRAY)
                /*
                 * LOC:    01234567
                 * ----------------
                 * RH[^2]= 00000000
                 * RH[^1]= 11111111
                 * CVP= 2    ^
                 * ----------------
                 * Then, Child (new rule) should be:
                 * LOC:    01234567
                 * ----------------
                 * NEW=    00111111
                 */

                int CrossoverPoint = rand.Next(1, RuleLength - 1);  // CVP
                ConsoleColor fgBak = Console.ForegroundColor;
                Console.ForegroundColor = ConsoleColor.Yellow;
                Console.WriteLine("CVP= " + CrossoverPoint);
                Console.ForegroundColor = fgBak;
                bool[] child = new bool[RuleLength];

                Console.ForegroundColor = ConsoleColor.DarkBlue;
                Console.Write("RH[^2]= ");
                for (int i = 0; i < ruleHistory[^2].Length; i++)
                {
                    Console.Write(ruleHistory[^2][i] ? 1 : 0);
                }
                Console.ForegroundColor = fgBak;
                Console.WriteLine();

                Console.ForegroundColor = ConsoleColor.DarkMagenta;
                Console.Write("RH[^1]= ");
                for (int i = 0; i < ruleHistory[^1].Length; i++)
                {
                    Console.Write(ruleHistory[^1][i] ? 1 : 0);
                }
                Console.ForegroundColor = fgBak;
                Console.WriteLine();

                Console.Write("CHILD= ");
                Console.ForegroundColor = ConsoleColor.DarkBlue;
                for (int i = 0; i < CrossoverPoint; i++)
                {
                    child[i] = ruleHistory[^2][i];
                    Console.Write(child[i] ? 1 : 0);
                }
                Console.ForegroundColor = ConsoleColor.DarkMagenta;
                for (int i = CrossoverPoint; i < RuleLength; i++)
                {
                    child[i] = ruleHistory[^1][i];
                    Console.Write(child[i] ? 1 : 0);
                }
                Console.ForegroundColor = fgBak;
                Console.WriteLine();
                ruleHistory.Add(child);
            }

            if (RankingHistory[^1] < RankingHistory[^2])
            {
                // Situation 3
                Console.WriteLine("S_3");

                int ToMutate = rand.Next(0, RuleLength);
                bool MutateToWhat = rand.Next(0, 2) == 1;
                ruleHistory.Add(ruleHistory[^2]);
                ruleHistory[^1][ToMutate] = MutateToWhat;
            }

            return ruleHistory[^1];
        }

    }
}