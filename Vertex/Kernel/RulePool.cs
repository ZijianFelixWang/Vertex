//#define __COMPARE_WITH_GREATEST__

using System;
using System.Collections.Generic;
//using System.Linq;
//using System.Collections;
//using NLog;
using ResourceHelper = Vertex.IOSupport.ResourceHelper;

namespace Vertex.Kernel
{
    class RulePool
    {
        //private static readonly Logger Logger = LogManager.GetCurrentClassLogger();

        // here implements the rule pool.
        // a rule is actually a bool[]

        // Definition of a rule:
        /*
         * Each cell in the matrix (excepted some configured VCIO cells) is
         * executed according to the general rule generated by RulePool.Next
         */

        public readonly ushort RuleLength = 0;
        public MutationMethod MutationMethod = MutationMethod.Flip;
        public ushort MutationCount = 1;

        public static int GetTimeStamp()
        {
            TimeSpan ts = DateTime.UtcNow - new DateTime(1970, 1, 1, 0, 0, 0, 0);
            return (int)Convert.ToInt64(ts.TotalMilliseconds);
        }

        public RulePool(ushort RuleLength)
        {
            // Actually is 512 but magical numbers should be avoided!
            this.RuleLength = RuleLength;

            // During initialization of env.RulePool, the very-first random rule
            // (Generation 0) will be created using the procedures below.
            bool[] gen0 = new bool[RuleLength];
            //Console.Write("G0= ");
            for (int i = 0; i < RuleLength; i++)
            {
                gen0[i] = Convert.ToBoolean(new Random(GetTimeStamp()).Next(0, 2));
                //    Console.Write(gen0[i] ? "1" : "0");
            }
            //Console.WriteLine();
            //Logger.Info("Generating G0 done.");
            ResourceHelper.Log("G0OKInfo");

            ruleHistory.Add(gen0);

            System.Threading.Thread.Sleep(2500);

            // (Generation 1) will be created using the procedures below.
            bool[] gen1 = new bool[RuleLength];
            //Console.Write("G1= ");
            for (int i = 0; i < RuleLength; i++)
            {
                gen1[i] = Convert.ToBoolean(new Random(GetTimeStamp()).Next(0, 2));
                //    Console.Write(gen1[i] ? "1" : "0");
            }
            ruleHistory.Add(gen1);
            //Console.WriteLine();
            //Logger.Info("Generating G1 done.");
            ResourceHelper.Log("G1OKInfo");
        }

        public bool[] GetLatest() => ruleHistory[^1];

        public List<bool[]> ruleHistory = new List<bool[]>();


        // rulepool doesn't care about how to execute rules. it only knows that
        // a rule is constructed using 512 bits (see Evaluator.cs)

        // Random maker
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Style", "IDE0044:Add readonly modifier", Justification = "<Pending>")]
        private Random rand = new Random(new Random(GetTimeStamp()).Next());

        //public bool[] Next(List<short> RankingHistory) => GetLatest();
        public bool[] Next() => GetLatest();

        private static (int i, short max) GetGreatest(List<short> RankingHistory)
        {
            int res = 0;
            short maxNow = RankingHistory[0];
            for (int i = 0; i < RankingHistory.Count; i++)
            {
                if (RankingHistory[i] > maxNow)
                {
                    res = i;
                    maxNow = RankingHistory[i];
                }
            }
            return (res, maxNow);
        }

        public bool[] Produce(List<short> RankingHistory)
        {
            if (RankingHistory is null)
            {
                throw new ArgumentNullException(nameof(RankingHistory));
            }

            // Function summary
            /*
             * Input:   None
             * Output:  Next rule
             * Features:
             *  This function returns next rule to perform according to the 
             *  rule ranking information. The ranking information is the
             *  comment ushort number to the performance of the current rule 
             *  which is just evaluated. The executor
             */

            // Just tried:  RankingHistory[RankingHistory.Count-1]
            //              OR: RankingHistory[^1]
            // Just tried:  ruleHistory[ruleHistory.Count-1]
            //              OR: ruleHistory[^1]

            // Detailed things to do:
            /*
             * If new ranking is greater than last one, mutate new ranking's rule
             * If new ranking is the same as last one, crossover rules then mutate
             * If new ranking is less than last one, mutate last ranking's rule
             * After this process record the new rule to history and then return it.
             */
            //Logger.Info("Producing new rule from history.");
            ResourceHelper.Log("ProduceRuleInfo");
#if __COMPARE_WITH_GREATEST__
            if (RankingHistory[^1] > GetGreatest(RankingHistory).max)
#else
            if (RankingHistory[^1] > RankingHistory[^2])
#endif
            {
                // Situation 1
                Console.Beep();
                ConsoleColor fgBak = Console.ForegroundColor;
                Console.ForegroundColor = ConsoleColor.Cyan;
                Console.WriteLine("Advantage generation.");
                Console.ForegroundColor = fgBak;

                ////Console.ForegroundColor = ConsoleColor.Yellow;
                //int ToMutate = rand.Next(0, RuleLength);
                //bool MutateToWhat;
                //if (MutationMethod == MutationMethod.Flip)
                //{
                //    MutateToWhat = !ruleHistory[^1][ToMutate];
                //}
                //else
                //{
                //    // MutationMethod == MutationMethod.Random
                //    MutateToWhat = rand.Next(0, 2) == 1;
                //}

                //Logger.Info($"Rule[{ToMutate}] mutates to {(MutateToWhat ? "1" : "0")}");
                ////Console.ForegroundColor = fgBak;

                //ruleHistory.Add(ruleHistory[^1]);
                //ruleHistory[^1][ToMutate] = MutateToWhat;

                // Mutation: utilize Mutate function
                bool[] rule = ruleHistory[^1];
                ushort mcnt = (ushort)rand.Next(1, MutationCount + 1);
                Mutate(ref rule, MutationMethod, mcnt);
                ruleHistory.Add(rule);
            }

#if __COMPARE_WITH_GREATEST__
            if (RankingHistory[^1] == GetGreatest(RankingHistory).max)
#else
            if (RankingHistory[^1] == RankingHistory[^2])
#endif            
            {
                // Situation 2
                ConsoleColor fgBak = Console.ForegroundColor;
                Console.ForegroundColor = ConsoleColor.Cyan;
                Console.WriteLine("Equallivant generation.");
                Console.ForegroundColor = fgBak;

                // Single-Point Crossover (SPCV) Algorithm:
                // For Example: (NOT REALLY 512 LENGTH ARRAY)
                /*
                 * LOC:    01234567
                 * ----------------
                 * RH[^2]= 00000000
                 * RH[^1]= 11111111
                 * CVP= 2    ^
                 * ----------------
                 * Then, Child (new rule) should be:
                 * LOC:    01234567
                 * ----------------
                 * NEW=    00111111
                 */

                int CrossoverPoint = rand.Next(1, RuleLength - 1);  // CVP
                //ConsoleColor fgBak = Console.ForegroundColor;
                Console.ForegroundColor = ConsoleColor.Yellow;
                //Logger.Info("CVP= " + CrossoverPoint);
                ResourceHelper.Log("CVPHint", CrossoverPoint.ToString());
                Console.ForegroundColor = fgBak;
                bool[] child = new bool[RuleLength];

                Console.ForegroundColor = ConsoleColor.DarkBlue;
                Console.Write("RH[^2]= ");
                for (int i = 0; i < ruleHistory[^1].Length; i++)
                {
                    //Console.Write(ruleHistory[GetGreatest(RankingHistory).i][i] ? 1 : 0);
                    Console.Write(ruleHistory[^2][i] ? 1 : 0);
                }
                Console.ForegroundColor = fgBak;
                Console.WriteLine();

                Console.ForegroundColor = ConsoleColor.Red;
                Console.Write("RH[^1]= ");
                for (int i = 0; i < ruleHistory[^1].Length; i++)
                {
                    Console.Write(ruleHistory[^1][i] ? 1 : 0);
                }
                Console.ForegroundColor = fgBak;
                Console.WriteLine();

                Console.Write("CHILD= ");
                Console.ForegroundColor = ConsoleColor.DarkBlue;
                for (int i = 0; i < CrossoverPoint; i++)
                {
                    child[i] = ruleHistory[^2][i];
                    Console.Write(child[i] ? 1 : 0);
                }
                Console.ForegroundColor = ConsoleColor.Red;
                for (int i = CrossoverPoint; i < RuleLength; i++)
                {
                    child[i] = ruleHistory[^1][i];
                    Console.Write(child[i] ? 1 : 0);
                }
                Console.ForegroundColor = fgBak;
                Console.WriteLine();
                ruleHistory.Add(child);

                bool[] r = ruleHistory[^1];
                ushort mcnt = (ushort)rand.Next(1, MutationCount + 1);

                Mutate(ref r, MutationMethod, mcnt);
                ruleHistory[^1] = r;
            }

#if __COMPARE_WITH_GREATEST__
            if (RankingHistory[^1] < GetGreatest(RankingHistory).max)
#else
            if (RankingHistory[^1] < RankingHistory[^2])
#endif            
            {
                // Situation 3
                ConsoleColor fgBak = Console.ForegroundColor;
                Console.ForegroundColor = ConsoleColor.Cyan;
                Console.WriteLine("Disadvantage generation.");
                Console.ForegroundColor = fgBak;

                //Console.ForegroundColor = ConsoleColor.Yellow;
                //int ToMutate = rand.Next(0, RuleLength);

                //bool MutateToWhat;
                //if (MutationMethod == MutationMethod.Flip)
                //{
                //    MutateToWhat = !ruleHistory[^1][ToMutate];
                //}
                //else
                //{
                //    // MutationMethod == MutationMethod.Random
                //    MutateToWhat = rand.Next(0, 2) == 1;
                //}

                //Logger.Info($"Rule[{ToMutate}] mutates to {(MutateToWhat ? "1" : "0")}");
                //ruleHistory.Add(ruleHistory[GetGreatest(RankingHistory).i]);
                //ruleHistory[^1][ToMutate] = MutateToWhat;

                // Mutation: utilize Mutate function
                bool[] rule = ruleHistory[^2];
                ushort mcnt = (ushort)rand.Next(1, MutationCount + 1);
                Mutate(ref rule, MutationMethod, mcnt);
                ruleHistory.Add(rule);
            }

            return ruleHistory[^1];
        }

        private void Mutate(ref bool[] rule, MutationMethod method, ushort mutationCount)
        {
            for (ushort i = 0; i < mutationCount; i++)
            {
                // Here defines a single mutation
                int ToMutate = rand.Next(0, RuleLength);
                bool MutateToWhat;
                if (method == MutationMethod.Flip)
                {
                    MutateToWhat = !rule[ToMutate];
                }
                else
                {
                    // Random method
                    MutateToWhat = rand.Next(0, 2) == 1;
                }
                //Logger.Info($"Rule[{ToMutate}] mutates from {rule[ToMutate]} to {(MutateToWhat ? "1" : "0")}");
                rule[ToMutate] = MutateToWhat;
            }
        }
    }

    enum MutationMethod
    {
        Flip, Random
    }
}